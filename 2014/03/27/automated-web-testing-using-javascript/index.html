<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Automated Web Testing using JavaScript - simonguest.com
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="The only person allowed to login as 'guest'">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Automated Web Testing using JavaScript</h1>
        <p class="author">Written by <span class="author">Simon Guest</span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>The process of creating automated tests for Web applications has been around for many years. Vendors such as <span class="caps">HP</span>, Parasoft, QFS, and even Microsoft have test software that can be used to create and run automated tests. Over the past couple of years however, we’ve seen an industry-trend towards open source Web testing solutions based on JavaScript. Such solutions have the advantage of being easily modified, free to download, very modular, supported by a vibrant community, and (given the popularity of client-side JavaScript) tests can often be written using the same language as the Web&nbsp;application. </p>
<p><span class="more"></span></p>
<p>For this blog post, I wanted to share some of our observations at Neudesic, and some of the tools that we’ve had success with during recent&nbsp;projects.</p>
<p><strong>Unit Tests or&nbsp;Assertions?</strong></p>
<p>Before considering any unit test, one of the questions we try to ask is whether the same functionality can be provided by an assertion. An assertion is, in its simplest form, code in your application that asserts that some condition is true – and if it’s false, stops the application and/or reports an error&nbsp;message.</p>
<p>The easiest way to perform an assertion in JavaScript is with the <strong>console.assert</strong> function. This is supported on the latest version of most major browsers (Chrome, Safari, and <span class="caps">IE</span> 10 upwards). A simple use of console.assert might look as&nbsp;follows:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> myMethod = <span class="function"><span class="keyword">function</span><span class="params">(x)</span>{</span>
  console.assert(x, <span class="string">'X should not be undefined'</span>);
  <span class="comment">/* rest of method goes here */</span>
};
</code></pre>
<p>As shown above, this is the simplest form of an assertion, yet quite effective. More importantly, it also negates the need to have a redundant unit test that checks whether the value of x is null, resulting in fewer tests that simply do assertion checking. There are many developers who use assertions during development and then strip out the assertions for production. While this has some merit, a more productive approach can be to create your own assertion function. This might look something like the&nbsp;following:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> myMethod = <span class="function"><span class="keyword">function</span><span class="params">(x)</span>{</span>
  assert(x, <span class="string">'X should not be undefined'</span>);
  <span class="comment">/* rest of method goes here */</span>
};
</code></pre>
<p>As shown above, instead of calling console.assert we call a custom function. This has the advantage that in development mode we can inject an assert function that writes to the console or adds a breakpoint in code, whereas in production mode we might choose to display a more friendly error message to the user and potentially log the crash via an analytics&nbsp;service.</p>
<p><strong>QUnit</strong></p>
<p>Assertions are useful for performing simple checks on methods, but there will likely come a time where you need to perform more rigorous tests of logic, using a unit test. <a href="http://qunitjs.com">QUnit</a> is a popular JavaScript framework for unit testing, whose origins come from jQuery and jQuery <span class="caps">UI</span>. QUnit works by defining a set of tests that are run within the QUnit test runner (which itself is just a Web page). Unit tests are simple, and follow a format similar to the&nbsp;following:</p>
<pre><code class="lang-javascript">test(&#39;a basic test example&#39;, function() {
  var value = &#39;hello&#39;;
  equal(value, ‘hello&#39;, &#39;We expect value to be hello&#39;);
})
</code></pre>
<p>If you are new to unit testing in JavaScript, and starting out by writing simple single page tests, QUnit is a good way to get&nbsp;started.</p>
<p><strong>Jasmine and&nbsp;Karma</strong></p>
<p>While QUnit provides a good introduction to unit testing, it is easy to quickly reach a limit, especially if your application has a lot of tests nested in a hierarchy. In addition, QUnit does not typically provide any <span class="caps">CI</span> (Continuous Integration) functionality out of the box. As you increase your familiarity with unit testing using JavaScript, it is well worth checking out <a href="http://jasmine.github.io">Jasmine</a> and <a href="http://karma-runner.github.io">Karma</a>.</p>
<p>Jasmine is a <span class="caps">BDD</span>-style framework for writing tests. While similar to the QUnit construct, the syntax tends to be cleaner and more widely adopted in the JavaScript&nbsp;community:</p>
<pre><code class="lang-javascript">describe(<span class="string">'a basic test example'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  it(<span class="string">'tests that true is always the truth'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  expect(<span class="literal">true</span>).toBe(<span class="literal">true</span>);
  });
});
</code></pre>
<p>As can be shown in the example above, the describe, it, and expect keywords work with unit tests, but also apply to <span class="caps">BDD</span> style tests also – making Jasmine a good candidate for writing tests of both types. Jasmine is just a language syntax and by design doesn’t offer any test runner implementation. Fortunately, there are a number of test runners available that can run Jasmine tests. One such framework gaining adoption is Karma, a test framework developed by the AngularJS team at&nbsp;Google.</p>
<p>Karma, which used to be called Testacular (insert your joke here about why the name changed!), is a flexible test framework that can be used to call unit tests written in Jasmine and other frameworks. Karma is very lightweight, which means it works well in <span class="caps">CI</span> (Continuous Integration) settings, even to the point where it’s possible to have Karma invoke a series of tests after each file save on your development machine. While there are many different test runners capable of executing unit tests, I believe Karma adoption will continue to grow, and this should be something that you should look at for your own testing&nbsp;needs.</p>
<p><strong>Selenium</strong></p>
<p>Unit testing is useful for testing discreet logic in your application, but falls short of telling you whether the application is working correctly for the user in their environment – i.e. through their browser. To do this we need to turn to integration testing – testing the end to end operation of your Web application. <a href="http://seleniumhq.org">Selenium</a> is an open source project that has been in development for the past 10 years, originally developed by <a href="http://thoughtworks.com">ThoughtWorks</a> as a replacement for Mercurial (hence the name, as Selenium is often used to cure Mercury&nbsp;poisoning!).</p>
<p>Today, Selenium has three major components: Selenium <span class="caps">IDE</span>, Selenium WebDriver, and Selenium&nbsp;Grid.</p>
<p><strong>Selenium <span class="caps">IDE</span></strong> is a browser extension for Firefox that enables you to record a series of actions and test assertions via a “recording function” in the browser. By default, the test gets written to a <span class="caps">HTML</span>-based test suite, and can be replayed at any time. While Selenium IDE is a useful tool for investigating the underlying operations of the testing platform, it is not well suited for use in production – the tests don’t support inheritance, which makes management of the tests difficult, especially when things change in your application. Moreover, the tests have to be run through the Firefox browser, which makes true automation&nbsp;difficult.</p>
<p><strong>Selenium WebDriver</strong> (which used to be Selenium <span class="caps">RC</span>) is a server-side version of the Selenium testing platform that does support scripted tests. WebDriver (based on the emerging WebDriver spec, hence the name), runs as a Java service and accepts incoming TCP socket connections from test clients. Upon receiving a connection, the service invokes a browser, runs the tests, and reports status back to the client via the socket. Any test platform that implements the <a href="https://dvcs.w3.org/hg/webdriver/raw-file/default/webdriver-spec.html">WebDriver specification</a> can issue tests to a Selenium&nbsp;server.</p>
<p><strong>Selenium Grid</strong> is a service where multiple Selenium servers can be clustered to handle a high volume of tests. It is often used by service providers (such as SauceLabs) who are offering testing services to multiple&nbsp;clients.</p>
<p>For many projects, Selenium WebDriver makes the most sense. In order to use WebDriver with Jasmine however, you still need to have a test runner (remember that Jasmine doesn’t provide any test platform). Karma is not a fit here as it is best suited for unit tests, not end-to-end tests (as it happens, the documentation actually discourages the use of Karma for integration testing). To solve this, we turn to another testing framework from Google, <a href="http://github.com/angular/protractor">Protractor</a>:</p>
<p><strong>Protractor</strong> is an end-to-end test framework, typically used to test <a href="http://angularjs.org">AngularJS</a> applications – although any Web application can be tested as protractor contains methods to call the underlying WebDriver implementation. It is built upon a library called <a href="https://code.google.com/p/selenium/wiki/WebDriverJs">WebDriverJS</a>, a JavaScript-implementation of the WebDriver client, which makes it wire compatible with Selenium WebDriver. Protractor is simple to install, and supports Jasmine as it’s primary test language. A test using protractor might look as&nbsp;follows:</p>
<pre><code class="lang-javascript">describe(<span class="string">'test hello world home page'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  it(<span class="string">'should greet the named user'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    browser.get(<span class="string">'http://www.angularjs.org'</span>);
    element(by.model(<span class="string">'yourName'</span>)).sendKeys(<span class="string">'Simon'</span>);
    <span class="keyword">var</span> greeting = element(by.binding(<span class="string">'yourName'</span>));
    expect(greeting.getText()).toEqual(<span class="string">'Hello Simon!'</span>);
  });
});
</code></pre>
<p>As you can see above, this simple test will open a Web page, look for a data binding called ‘yourName’, send a name to it, and then assert that the greeting replied is correct. You should note that the model and binding above are specific to AngularJS, and (if you are not using AngularJS) can be replaced with similar lookups based on <span class="caps">HTML</span> ID, CSS, or XPATH query. Using the protractor test runner, this test can be sent to an instance of Selenium, which in turn will invoke a new browser, run the test, and report back the results to the&nbsp;client.</p>
<p><strong>IDEs for Creating Protractor Tests. </strong>While creating tests is a manual process today, there are several open source projects with a goal of being able to generate protractor-based tests from a more visual interface. One such tool is <a href="http://sebuilder.github.io/se-builder/">Selenium Builder</a>, which while still in Alpha, looks very&nbsp;promising.</p>
<p><strong>Using Page Objects.</strong> While Jasmine and Protractor offer a very quick way of creating and running tests, you often need to be careful to manage the tests that you create. If you make a simple change in the <span class="caps">UI</span>, you want to avoid a situation where you need to change many tests. One way of overcoming this is to use <a href="https://github.com/angular/protractor/blob/master/docs/getting-started.md#organizing-real-tests-page-objects">Page Objects</a> when using Protractor. A Page Object is, by definition, a JavaScript class that defines methods on a&nbsp;page.</p>
<p>These methods might be AddCustomer, DeleteCustomer, ModifyCustomer, etc. The tests then call these page objects to perform the function. For example, AddCustomer(valid), AddCustomer(invalid), AddCustomer(invalid2), etc. This approach offers many advantages, especially if the page changes. If a change to page occurs, only the page object has to be changed once, which makes maintenance and re-use throughout the tests more&nbsp;predictable.</p>
<p><strong>PhantomJS.</strong> Finally, as we discussed previously, Selenium works by invoking a new browser process in order to run tests. While this is useful on your development machine, there are times where you may want to invoke tests that do not have access to a fully installed browser – for example, if you are doing server-side tests on a Linux or a <a href="http://docker.io">Docker</a> instance without a <span class="caps">UI</span> installed. To accomplish this, <a href="http://phantomjs.org">PhantomJS</a> can be used. PhantomJS is a headless version of WebKit written in Qt, and can act as a browser without any of the <span class="caps">UI</span> overhead associated with actually launching a&nbsp;browser.</p>
<p>PhantomJS can be invoked in one of two ways – either plugged directly into Selenium as an alternative browser process – or, because PhantomJS implements <a href="https://github.com/detro/ghostdriver">GhostDriver</a> (wire level compatibility with WebDriver), it can be called directly from Protractor. PhantomJS is still in early development stages (and at the time of writing being ported to Qt5), but looks to offer a lot of potential for developers who are looking to do integration testing in a headless&nbsp;environment.</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">« Full blog</a></div>
        <section class="about"><p>Simon Guest is the VP of Platform R&amp;D at Concur Technologies, passionate about software engineering, API design, and developer experience.</p>
<p>Simon is a certified IT Architect (CITA-P), a member of the British Computer Society (MBCS), was named as one of “Microsoft’s Key Employee Losses of 2010″ by eWeek, and has been awarded a place on Sun Microsystems’ “Speaker Wall of Fame” on two occasions.</p>
<p>In addition to speaking, Simon enjoys writing, is the author of numerous articles, patents, and books, and maintains an active blog at <a href="http://simonguest.com">http://simonguest.com</a>.</p>
<p>You can get in touch with Simon through <a href="http://linkedin.com/pub/simonguest">LinkedIn</a></p>

        </section>
        <section class="copy">
          <p>&copy; 2014 Simon Guest &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>